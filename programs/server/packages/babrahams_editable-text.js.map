{"version":3,"sources":["babrahams:editable-text/lib/editable_text_common.js","babrahams:editable-text/lib/editable_text_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,0C;AACA,oB;AACA,C;;;AAGA,6C;AACA,6C;AACA,6C;;AAEA,qD;AACA,gD;AACA,kB;AACA,C;;AAEA,yG;AACA,gD;;AAEA,mF;;AAEA,4F;AACA,yE;AACA,sB;AACA,oB;AACA,2B;AACA,0N;AACA,2D;AACA,4F;AACA,0D;AACA,Q;AACA,C;;AAEA,4B;AACA,kF;AACA,6L;AACA,gD;AACA,E;;;AAGA,6C;AACA,6C;AACA,6C;;AAEA,2D;;AAEA,wC;AACA,2B;AACA,sC;AACA,wE;AACA,iC;AACA,mC;AACA,U;AACA,e;AACA,+D;AACA,U;AACA,Q;AACA,wH;AACA,gC;AACA,mC;AACA,U;AACA,e;AACA,8D;AACA,U;AACA,Q;AACA,qD;AACA,+B;AACA,oC;AACA,U;AACA,Q;AACA,Q;AACA,G;AACA,Q;AACA,mH;AACA,G;AACA,C;;AAEA,qC;;AAEA,gD;AACA,wB;AACA,kC;AACA,8B;AACA,2C;AACA,O;AACA,Y;AACA,wG;AACA,O;AACA,O;AACA,G;AACA,Q;AACA,8E;AACA,G;AACA,C;;;AAGA,oC;AACA,oC;AACA,oC;;AAEA,6B;;AAEA,iD;AACA,8B;AACA,kB;AACA,qD;AACA,4E;AACA,sD;AACA,G;AACA,a;AACA,C;;AAEA,yE;AACA,uB;AACA,uE;AACA,2D;AACA,qG;AACA,G;AACA,Q;AACA,qT;AACA,G;AACA,oB;AACA,C;;AAEA,6C;AACA,8D;AACA,C;;AAEA,wC;AACA,yC;AACA,8F;AACA,oC;AACA,4C;AACA,yC;AACA,G;AACA,iB;AACA,C;;;AAGA,gB;AACA,gB;AACA,gB;;AAEA,gB;AACA,mE;AACA,yB;AACA,uB;AACA,kC;AACA,uG;AACA,0D;AACA,+B;AACA,6D;AACA,gE;AACA,mE;AACA,2D;AACA,+G;AACA,oF;AACA,yB;AACA,oG;AACA,qD;AACA,S;AACA,O;AACA,sC;AACA,gC;AACA,O;AACA,yC;AACA,iD;AACA,O;AACA,wB;AACA,qC;AACA,oC;AACA,gF;AACA,S;AACA,O;AACA,uB;AACA,uB;AACA,gC;AACA,yD;AACA,qE;AACA,W;AACA,4B;AACA,oE;AACA,mF;AACA,a;AACA,yG;AACA,8E;AACA,6F;AACA,oE;AACA,0B;AACA,a;AACA,W;AACA,gB;AACA,yG;AACA,yK;AACA,6F;AACA,W;AACA,wB;AACA,gB;AACA,uB;AACA,gC;AACA,kC;AACA,+E;AACA,uC;AACA,kH;AACA,+B;AACA,a;AACA,8E;AACA,qJ;AACA,+B;AACA,a;AACA,+E;AACA,sD;AACA,mC;AACA,a;AACA,yF;AACA,4H;AACA,mC;AACA,a;AACA,iF;AACA,oH;AACA,mC;AACA,a;AACA,6B;AACA,4E;AACA,a;AACA,W;AACA,gB;AACA,kM;AACA,W;AACA,mC;AACA,mD;AACA,4B;AACA,oE;AACA,sF;AACA,a;AACA,yG;AACA,8E;AACA,uG;AACA,oE;AACA,0B;AACA,a;AACA,W;AACA,gB;AACA,yG;AACA,wC;AACA,2G;AACA,a;AACA,kB;AACA,2E;AACA,a;AACA,uG;AACA,W;AACA,gB;AACA,uB;AACA,4B;AACA,oE;AACA,sF;AACA,a;AACA,yG;AACA,4E;AACA,yE;AACA,oE;AACA,0B;AACA,c;AACA,W;AACA,gB;AACA,yG;AACA,gE;AACA,yE;AACA,W;AACA,kB;AACA,O;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AChRA,0C;AACA,oB;AACA,C;;AAEA,wF;AACA,iE;;AAEA,gD;AACA,yE;AACA,qC;AACA,uC;AACA,2C;AACA,K;AACA,yB;AACA,C;;AAEA,mD;AACA,gC;AACA,+B;AACA,8B;AACA,uD;AACA,kC;AACA,6C;AACA,uC;AACA,O;AACA,K;AACA,oF;AACA,+B;AACA,uD;AACA,K;AACA,K;AACA,a;AACA,C","file":"/packages/babrahams_editable-text.js","sourcesContent":["if (typeof EditableText === 'undefined') {\n  EditableText = {};\n}\n\n\n// ******************************************\n// CONFIG that affects BOTH CLIENT AND SERVER\n// ******************************************\n\nEditableText.userCanEdit = function(doc,Collection) {\n  // e.g. return this.user_id = Meteor.userId();\n  return true;    \n}\n\nEditableText.useTransactions = (typeof tx !== 'undefined' && _.isObject(tx.Transactions)) ? true : false;\nEditableText.clientControlsTransactions = false;\n\nEditableText.maximumImageSize = 0; // Can't put image data in the editor by default\n\n// This is the set of defaults for sanitizeHtml on the server (as set by the library itself)\n// Required on the client for consistency of filtering on the paste event\nif (Meteor.isClient) {\n  sanitizeHtml = {};\n  sanitizeHtml.defaults = {\n    allowedTags: [ 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre' ],\n    allowedAttributes: { a: [ 'href', 'name', 'target' ] },\n    selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n    allowedSchemes: [ 'http', 'https', 'ftp', 'mailto' ]  \n  };    \n}\n\nEditableText.allowedHtml = {\n  allowedTags: sanitizeHtml.defaults.allowedTags.concat(['sub','sup','font','i']),\n  allowedAttributes: _.extend(sanitizeHtml.defaults.allowedAttributes,{font:['size','face'],div:['align','style'],td:['rowspan','colspan','style'],a:['href','target','class'],i:['class']}),\n  allowedSchemes:['http','https','ftp','mailto']\n};\n\n\n// ******************************************\n// Functions that are intended for use in app\n// ******************************************\n\n// Function for setting multiple config variable via a hash\n\nEditableText.config = function(config) {\n  if (_.isObject(config)) {\n     _.each(config,function(val,key) {\n       if (_.contains(['userCanEdit','insert','update','remove'],key)) {\n         if (_.isFunction(val)) {\n           EditableText[key] = val;\n         }\n         else {\n           throw new Meteor.Error(key + ' must be a function');\n         }\n       }\n       if (_.contains(['useTransactions','clientControlsTransactions','saveOnFocusout','trustHtml','useMethods'],key)) {\n         if (_.isBoolean(val)) {\n           EditableText[key] = val;\n         }\n         else {\n           throw new Meteor.Error(key + ' must be a boolean');\n         }\n       }\n       if (_.contains(['collection2Options'], key)) {\n         if (_.isObject(val)) {\n            EditableText[key] = val;\n         }\n       }\n     });\n  }\n  else {\n    throw new Meteor.Error('Editable text config object must be a hash of key value pairs. Config not changed.');  \n  }\n}\n\n// Function for registering callbacks\n\nEditableText.registerCallbacks = function(obj) {\n  if (_.isObject(obj)) {\n    _.each(obj,function(val,key) {\n      if (_.isFunction(val)) {\n        EditableText._callbacks[key] = val;\n      }\n      else {\n        throw new Meteor.Error('Callbacks need to be functions. You passed a ' + typeof(val) + '.');    \n      }\n    });\n  }\n  else {\n    throw new Meteor.Error('You must pass an object to register callbacks');  \n  }\n}\n\n\n// *********************************\n// INTERNAL PROPERTIES AND FUNCTIONS\n// *********************************\n\nEditableText._callbacks = {};\n\nEditableText._callback = function(callback,doc) {\n  callback = String(callback);\n  var self = this;\n  if (self[callback] && _.isString(self[callback])) {\n    var mutatedDoc = EditableText._executeCallback(self[callback],self,doc);\n    doc = _.isObject(mutatedDoc) && mutatedDoc || doc;\n  }\n  return doc;\n}\n\nEditableText._executeCallback = function(callbackFunctionName,self,doc) {\n  var mutatedDoc = doc;\n  var callbackFunction = EditableText._callbacks[callbackFunctionName];\n  if (callbackFunction && _.isFunction(callbackFunction)) {\n    mutatedDoc = callbackFunction.call(self,doc,Mongo.Collection.get(self.collection)) || mutatedDoc;\n  }\n  else {\n    throw new Meteor.Error('Could not execute callback. Reason: ' + ((callbackFunction) ? '\"' + callbackFunctionName + '\" is not a function, it\\'s a ' + typeof(callbackFunction) + '.' : 'no callback function called \"' + callbackFunctionName + '\" has been registered via EditableText.registerCallbacks.'));    \n  }\n  return mutatedDoc;\n}\n\nEditableText._drillDown = function(obj,key) {\n  return Meteor._get.apply(null,[obj].concat(key.split('.')));\n}\n\nEditableText._allowedHtml = function() {\n  var allowed = EditableText.allowedHtml;\n  if (EditableText.maximumImageSize && _.isNumber(EditableText.maximumImageSize) && allowed) {\n    allowed.allowedTags.push('img');\n    allowed.allowedAttributes.img = ['src'];\n    allowed.allowedSchemes.push('data'); \n  }\n  return allowed;\n}\n\n\n// *************\n// UPDATE METHOD\n// *************\n\nMeteor.methods({\n  _editableTextWrite : function(action,data,modifier,transaction) {\n    check(action,String);\n    check(data,Object);\n    check(data.collection,String);\n    check(data.context,(typeof FS !== \"undefined\" && FS.File) ? Match.OneOf(Object, FS.File) : Object);\n    check(modifier,(action === 'update') ? Object : null);\n    check(transaction,Boolean);\n    check(data.objectTypeText,Match.OneOf(String,undefined));\n    var hasPackageCollection2 = !!Package['aldeed:collection2'];\n    var hasPackageSimpleSchema = !!Package['aldeed:simple-schema'];\n    var Collection = Mongo.Collection.get(data.collection);\n    var c2optionsHashRequired = hasPackageCollection2 && hasPackageSimpleSchema && !!Collection.simpleSchema();\n    if (Collection && EditableText.userCanEdit.call(data,data.context,Collection)) {\n\t  if (Meteor.isServer) {\n        if (_.isBoolean(EditableText.useTransactions) && !EditableText.clientControlsTransactions) {\n          transaction = EditableText.useTransactions;\n        }\n      }\n      if (typeof tx === 'undefined') {\n        transaction = false;    \n      }\n      var setStatus = function(err,res) {\n        data.status = {error:err,result:res};    \n      }\n      if (transaction) {\n        var options = {instant:true};\n        if (c2optionsHashRequired) {\n          options = _.extend(options,EditableText.collection2options || {});    \n        }\n      }\n      switch (action) {\n        case 'insert' :\n          if (Meteor.isServer) {\n            // run all string fields through sanitizeHtml\n            data.context = EditableText.sanitizeObject(data.context);\n          }\n          if (transaction) {\n            if (data.objectTypeText || data.transactionInsertText) {\n              tx.start(data.transactionInsertText || 'add ' + data.objectTypeText);\n            }\n            data.context = EditableText._callback.call(data,'beforeInsert',data.context) || data.context;\n            var new_id = tx.insert(Collection,data.context,options,setStatus);\n            EditableText._callback.call(data,'afterInsert',Collection.findOne({_id:new_id}));\n            if (data.objectTypeText || data.transactionInsertText) {\n              tx.commit();\n            }\n          }\n          else {\n            data.context = EditableText._callback.call(data,'beforeInsert',data.context) || data.context;\n            var new_id = (c2optionsHashRequired) ? Collection.insert(data.context,EditableText.collection2options,setStatus) : Collection.insert(data.context,setStatus);\n            EditableText._callback.call(data,'afterInsert',Collection.findOne({_id:new_id}));\n          }\n          return new_id;\n          break;\n        case 'update' :\n          if (Meteor.isServer) {\n            var sanitized = false;\n            if (modifier[\"$set\"] && _.isString(modifier[\"$set\"][data.field])) {\n            // run through sanitizeHtml\n              newValue = modifier[\"$set\"][data.field] = EditableText.sanitizeString(modifier[\"$set\"][data.field]);\n              sanitized = true;\n            }\n            if (modifier[\"$set\"] && _.isArray(modifier[\"$set\"][data.field])) {\n              newValue = modifier[\"$set\"][data.field] = _.map(modifier[\"$set\"][data.field],function(str) {return EditableText.sanitizeString(str);});\n              sanitized = true;\n            }\n            if (modifier[\"$set\"] && _.isNumber(modifier[\"$set\"][data.field])) {\n              newValue = modifier[\"$set\"][data.field];\n              sanitized = true;    \n            }\n            if (modifier[\"$addToSet\"] && _.isString(modifier[\"$addToSet\"][data.field])) {\n              newValue = modifier[\"$addToSet\"][data.field] = EditableText.sanitizeString(modifier[\"$addToSet\"][data.field]);\n              sanitized = true;    \n            }\n            if (modifier[\"$push\"] && _.isString(modifier[\"$push\"][data.field])) {\n              newValue = modifier[\"$push\"][data.field] = EditableText.sanitizeString(modifier[\"$push\"][data.field]);\n              sanitized = true;    \n            }\n            if (!sanitized) {\n              throw new Meteor.Error('Wrong data type sent for update');    \n            }\n          }\n          else {\n            newValue = (modifier[\"$set\"] && modifier[\"$set\"][data.field]) || (modifier[\"$addToSet\"] && modifier[\"$addToSet\"][data.field]) || (modifier[\"$push\"] && modifier[\"$push\"][data.field]);\n          }\n          data.newValue = newValue;\n          data.oldValue = data.context[data.field];\n          if (transaction) {\n            if (data.transactionUpdateText || data.objectTypeText) {\n              tx.start(data.transactionUpdateText || 'update ' + data.objectTypeText);\n            }\n            data.context = EditableText._callback.call(data,'beforeUpdate',data.context) || data.context;\n            tx.update(Collection,data.context._id,modifier,options,setStatus);\n            EditableText._callback.call(data,'afterUpdate',Collection.findOne({_id:data.context._id}));\n            if (data.transactionUpdateText || data.objectTypeText) {\n              tx.commit();\n            }\n          }\n          else {\n            data.context = EditableText._callback.call(data,'beforeUpdate',data.context) || data.context;\n            if (c2optionsHashRequired) {\n              Collection.update({_id:data.context._id},modifier,EditableText.collection2options,setStatus);\n            }\n            else {\n              Collection.update({_id:data.context._id},modifier,setStatus);\n            }\n            EditableText._callback.call(data,'afterUpdate',Collection.findOne({_id:data.context._id}));\n          }\n          break;\n        case 'remove' :\n          if (transaction) {\n            if (data.transactionRemoveText || data.objectTypeText) {\n              tx.start(data.transactionRemoveText || 'remove ' + data.objectTypeText);\n            }\n            data.context = EditableText._callback.call(data,'beforeRemove',data.context) || data.context;\n            tx.remove(Collection,data.context._id,{instant:true},setStatus);\n            EditableText._callback.call(data,'afterRemove',data.context);\n            if (data.transactionRemoveText || data.objectTypeText) {\n              tx.commit();\n            } \n          }\n          else {\n            data.context = EditableText._callback.call(data,'beforeRemove',data.context) || data.context;\n            Collection.remove({_id:data.context._id},setStatus);\n            EditableText._callback.call(data,'afterRemove',data.context);\n          }\n          break;  \n      }\n    }\n  }\n});","if (typeof EditableText === 'undefined') {\n  EditableText = {};\n}\n\n// Only used in the _editableTextWrite method detects the presence of aldeed:collection2\nEditableText.collection2Options = {filter: true, validate: true};\n\nEditableText.sanitizeString = function(string) {\n  var sanitizedString = sanitizeHtml(string,EditableText._allowedHtml());\n  /*if (string !== sanitizedString) {\n    console.log(\"Sanitized: \", string);\n    console.log(\"To: \", sanitizedString);  \n  }*/\n  return sanitizedString;\n}\n\nEditableText.sanitizeObject = function(obj,allow) {\n  _.each(obj,function(val,key) {\n    if (_.isString(obj[key])) {\n      var original = obj[key];\n      obj[key] = EditableText.sanitizeString(obj[key]);\n      if (original !== obj[key]) {\n        console.log(\"Sanitized: \", original);\n        console.log(\"To: \",obj[key]);  \n      }\n    }\n    // If it's another object, need to recurse into that object and clean up strings\n    if (_.isObject(obj[key])) {\n      obj[key] = EditableText.sanitizeObject(obj[key]);\n    }\n  });\n  return obj;\n}"]}